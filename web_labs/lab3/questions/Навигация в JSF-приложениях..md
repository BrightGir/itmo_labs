# Навигация в JSF-приложениях

**Навигация в JSF** — это механизм перехода пользователя с одной страницы на другую, как правило, в результате выполнения какого-либо действия (например, нажатия на кнопку). Сердцем навигации является **строка-результат (outcome string)**, которую возвращает метод-действие (action method) в управляемом бине.

JSF предлагает два основных механизма навигации:
1.  **Неявная (Implicit)** — современный, гибкий и рекомендуемый способ.
2.  **Явная (Explicit)** — через конфигурацию в `faces-config.xml`, устаревший подход.

---

## 1. Неявная навигация (Implicit Navigation)

Это стандартный механизм в JSF 2.x. Фреймворк сам определяет, на какую страницу перейти, основываясь на строке, которую вернул метод.

**Основное правило**: Если метод возвращает строку `outcome`, JSF по умолчанию ищет файл с именем `outcome.xhtml` в той же директории, где находится текущая страница.

### Как это работает:

**1. Компонент в `.xhtml` файле:**
Кнопка или ссылка привязывается к методу в бине через атрибут `action`.

```xml
<h:form>
    <h:inputText value="#{loginBean.username}" />
    <h:inputSecret value="#{loginBean.password}" />
    
    <!-- При нажатии будет вызван метод login() в бине loginBean -->
    <h:commandButton value="Login" action="#{loginBean.login}" />
</h:form>
````

**2. Метод-действие в управляемом бине:**  
Метод выполняет бизнес-логику и возвращает строку-результат.

```java
@Named("loginBean")
@RequestScoped
public class LoginBean {
    private String username;
    private String password;
    // геттеры и сеттеры

    public String login() {
        if ("admin".equals(username) && "12345".equals(password)) {
            // В случае успеха, JSF будет искать страницу 'welcome.xhtml'
            return "welcome"; 
        } else {
            // В случае неудачи, JSF будет искать 'error.xhtml'
            return "error"; 
        }
    }
}
```

- **Возврат null или void**: Если метод действия возвращает null или имеет тип void, навигации не происходит. Пользователь остается на той же странице. Это очень полезно при использовании AJAX, когда нужно обновить только часть страницы без перехода.
---

### ## 2. Явная навигация через faces-config.xml (Устаревший подход)

В JSF 1.x все правила навигации жестко прописывались в файле WEB-INF/faces-config.xml. Это делало систему громоздкой и трудной для рефакторинга.

**Как это работало:**  
В файле создавались теги **navigation-rule**, которые описывали, с какой страницы (с помощью тега **from-view-id**), по какому результату (**from-outcome**) и на какую страницу (**to-view-id**) нужно перейти.

**Пример в faces-config.xml:**

```xml
<navigation-rule>
    <!-- Правило для страницы login.xhtml -->
    <from-view-id>/login.xhtml</from-view-id>

    <!-- Случай 1: успешная авторизация -->
    <navigation-case>
        <!-- Если метод, вызванный из action, вернул "success" -->
        <from-outcome>success</from-outcome>
        <!-- ... то перейти на страницу /main/dashboard.xhtml -->
        <to-view-id>/main/dashboard.xhtml</to-view-id>
        <!-- и выполнить редирект -->
        <redirect/>
    </navigation-case>

    <!-- Случай 2: неудачная авторизация -->
    <navigation-case>
        <from-outcome>failure</from-outcome>
        <to-view-id>/error.xhtml</to-view-id>
    </navigation-case>
</navigation-rule>
```

**Недостатки**:

- **Централизация**: Все правила в одном месте, что неудобно для больших приложений.
    
- **Жесткость**: Любое переименование файла требует правки XML.
    
- **Многословность**: Требуется много XML-кода для описания простых переходов.
    

**Статус**: Этот подход **не рекомендуется** для новых проектов, но его важно знать для поддержки старого кода.

---

## 3. Важные аспекты навигации

### Redirect vs Forward (Это важно!)

По умолчанию JSF выполняет **Forward (перенаправление на стороне сервера)**.

- **Как работает**: Сервер внутренне передает управление другой странице, но URL в браузере пользователя **не меняется**.
    
- **Проблема**: Если пользователь обновит страницу (F5), браузер повторно отправит последний POST-запрос, что может привести к дублированию действий (например, повторная отправка формы).
    

Чтобы решить эту проблему, используется **Redirect (перенаправление на стороне клиента)**.

- **Как работает**: Сервер отправляет браузеру ответ с кодом 302 и новым URL. Браузер выполняет новый GET-запрос на этот URL.
    
- **Преимущества**: URL в строке браузера обновляется, и проблема с обновлением страницы (F5) решается. Этот паттерн называется **Post-Redirect-Get (PRG)**.
    

**Как выполнить редирект в неявной навигации?**  
Нужно просто добавить магический параметр ?faces-redirect=true к строке-результату.

```java
public String saveOrder() {
    // ... логика сохранения заказа ...
    
    // После сохранения перенаправляем пользователя на страницу с подтверждением
    return "order-success?faces-redirect=true";
}
```

### Навигация без Action-методов

Для простых переходов между страницами, которые не требуют выполнения бизнес-логики, не нужно создавать метод в бине. Можно использовать компоненты h:link или h:button.

- h:commandLink / h:commandButton → **используют action**, запускают жизненный цикл JSF, предназначены для действий.
    
- h:link / h:button → **используют outcome**, не запускают жизненный цикл, генерируют простую ссылку `<a>` для навигации.
    


```xml
<!-- Простой переход на страницу about.xhtml без вызова метода в бине -->
<h:link value="О компании" outcome="about" />

<!-- Аналогично, но в виде кнопки -->
<h:button value="Контакты" outcome="contact" />
```

### Сводная таблица

|   |   |   |
|---|---|---|
|Критерий|Неявная навигация|Явная навигация (XML)|
|**Способ определения**|По имени файла, совпадающего с outcome|В файле faces-config.xml|
|**Гибкость**|Высокая, легко менять и рефакторить|Низкая, жесткая привязка|
|**Многословность**|Минимальная|Очень высокая|
|**Централизация**|Децентрализовано (логика в бине)|Централизовано (все в XML)|
|**Рекомендация**|**Стандарт для современных приложений**|Устаревший подход|