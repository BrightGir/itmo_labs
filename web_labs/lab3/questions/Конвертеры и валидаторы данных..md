# Конвертеры и Валидаторы данных в JSF

Конвертеры и Валидаторы — это два ключевых механизма в JSF, которые работают в паре для обработки пользовательского ввода. Они выполняют две разные, но последовательные задачи в жизненном цикле JSF.

-   **Конвертер (Converter)**: **Преобразует** данные.
-   **Валидатор (Validator)**: **Проверяет** данные.

**Порядок их работы:**
1.  Пользователь вводит данные в виде строки (String) в HTML-форму.
2.  **Конвертер** пытается преобразовать эту строку в нужный Java-тип (например, `Date`, `Integer`).
3.  Если конвертация прошла успешно, **Валидатор** проверяет полученный Java-объект на соответствие бизнес-правилам (например, входит ли дата в допустимый диапазон).

---

## 1. Конвертеры (Converters)

**Задача**: Преобразование данных между их строковым представлением (в HTML) и объектным представлением (в Java) и обратно.

-   `String -> Object`: Когда пользователь отправляет форму (submit).
-   `Object -> String`: Когда данные из Java-бина отображаются на странице.

### Стандартные конвертеры

JSF предоставляет набор готовых конвертеров, которые можно использовать с помощью тегов `<f:converterName>`.

-   **`<f:convertNumber>`**: Для числовых типов (`Integer`, `Double`, `BigDecimal`).
    -   Атрибуты: `type` (`currency`, `percent`), `pattern` (`#,##0.00`), `currencySymbol` и др.
-   **`<f:convertDateTime>`**: Для дат и времени (`java.util.Date`, `java.time.*`).
    -   Атрибуты: `pattern` (`dd.MM.yyyy HH:mm`), `type` (`date`, `time`, `both`).

**Пример использования стандартного конвертера:**

```xml
<h:inputText value="#{eventBean.eventDate}">
    <!-- Ожидает ввод даты в формате "день.месяц.год" -->
    <f:convertDateTime pattern="dd.MM.yyyy" />
</h:inputText>

<h:inputText value="#{productBean.price}">
    <!-- Отобразит и примет число как валюту -->
    <f:convertNumber type="currency" currencySymbol="₽" />
</h:inputText>

```

### Создание кастомного конвертера

Иногда нужно преобразовывать сложные или нестандартные типы данных (например, объект User в его id и обратно).

**Шаги:**

1. Создать класс, реализующий интерфейс javax.faces.convert.Converter.
    
2. Реализовать два метода:
    
    - getAsObject(FacesContext, UIComponent, String value): Преобразует строку из формы в Java-объект.
        
    - getAsString(FacesContext, UIComponent, Object value): Преобразует Java-объект в строку для отображения.
        
3. Зарегистрировать конвертер с помощью аннотации @FacesConverter("myConverterId").
    

**Пример: Конвертер для номера телефона +7(XXX)XXX-XX-XX**

```java
// PhoneNumber.java - наш кастомный класс
public class PhoneNumber {
    // поля, конструкторы, геттеры/сеттеры
}

// PhoneNumberConverter.java
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.convert.FacesConverter;

@FacesConverter("phoneNumberConverter")
public class PhoneNumberConverter implements Converter {

    @Override
    public Object getAsObject(FacesContext context, UIComponent component, String value) {
        // Преобразуем строку "+7(999)123-45-67" в объект PhoneNumber
        if (value == null || value.isEmpty()) {
            return null;
        }
        // ... логика парсинга строки ...
        return new PhoneNumber(value); 
    }

    @Override
    public String getAsString(FacesContext context, UIComponent component, Object value) {
        // Преобразуем объект PhoneNumber в строку "+7(999)123-45-67"
        if (!(value instanceof PhoneNumber)) {
            return "";
        }
        PhoneNumber phone = (PhoneNumber) value;
        // ... логика форматирования ...
        return phone.getFormattedString();
    }
}
```

**Использование кастомного конвертера в XHTML:**


```java
<h:inputText value="#{userBean.phoneNumber}">
    <f:converter converterId="phoneNumberConverter" />
</h:inputText>
```

---

## 2. Валидаторы (Validators)

**Задача**: Проверка корректности данных **после** того, как они были успешно сконвертированы. Если данные невалидны, валидатор добавляет сообщение об ошибке в FacesContext.

### Стандартные валидаторы

- **<f:validateLength>**: Проверяет минимальную и/или максимальную длину строки.
    
- **<f:validateLongRange>**: Проверяет, что число находится в заданном диапазоне (min/max).
    
- **<f:validateDoubleRange>**: Аналогично для чисел с плавающей точкой.
    
- **<f:validateRegex>**: Проверяет соответствие строки регулярному выражению.
    
- **<f:validateRequired>**: Хотя чаще используется атрибут required="true" у компонента, этот тег тоже существует.
    

**Пример использования стандартного валидатора:**


```xml
<h:inputSecret value="#{userBean.password}" required="true" label="Пароль">
    <!-- Пароль должен быть от 8 до 30 символов -->
    <f:validateLength minimum="8" maximum="30" />
</h:inputSecret>

<h:inputText value="#{orderBean.quantity}" label="Количество">
    <!-- Количество должно быть от 1 до 100 -->
    <f:validateLongRange minimum="1" maximum="100" />
</h:inputText>
```

### Создание кастомного валидатора

**Шаги:**

1. Создать класс, реализующий интерфейс javax.faces.validator.Validator.
    
2. Реализовать один метод validate(FacesContext, UIComponent, Object value). В этом методе, если валидация не пройдена, нужно сгенерировать ValidatorException.
    
3. Зарегистрировать валидатор с помощью аннотации @FacesValidator("myValidatorId").
    

**Пример: Валидатор, проверяющий, что email уникален (не занят)**


```java
import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.validator.FacesValidator;
import javax.faces.validator.Validator;
import javax.faces.validator.ValidatorException;

@FacesValidator("uniqueEmailValidator")
public class UniqueEmailValidator implements Validator {

    // В реальном приложении здесь был бы @Inject EJB или сервис
    private UserService userService = new UserService(); 

    @Override
    public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {
        String email = (String) value;

        if (userService.isEmailTaken(email)) {
            FacesMessage msg = 
                new FacesMessage("Ошибка валидации Email", "Этот Email уже зарегистрирован.");
            msg.setSeverity(FacesMessage.SEVERITY_ERROR);
            throw new ValidatorException(msg);
        }
    }
}
```

**Использование кастомного валидатора в XHTML:**


```xml
<h:inputText id="email" value="#{userBean.email}">
    <f:validator validatorId="uniqueEmailValidator" />
</h:inputText>
<h:message for="email" style="color:red" />
```

---

## Сравнительная таблица

|   |   |   |
|---|---|---|
|Критерий|Конвертер (Converter)|Валидатор (Validator)|
|**Цель**|**Преобразовать** данные|**Проверить** данные|
|**Основной интерфейс**|javax.faces.convert.Converter|javax.faces.validator.Validator|
|**Ключевой метод**|getAsObject(), getAsString()|validate()|
|**Входные данные**|Строка String или Объект Object|**Уже сконвертированный** Объект Object|
|**Результат при успехе**|Готовый Java-объект|Ничего (просто продолжает выполнение)|
|**Результат при ошибке**|ConverterException|ValidatorException|
|**Порядок выполнения**|**Первый** в цепочке обработки|**Второй** (после успешной конвертации)|