# Управляемые бины (Managed Beans) в JSF

**Управляемый бин (Managed Bean)** — это обычный Java-класс (POJO - Plain Old Java Object), жизненным циклом которого управляет JSF-контейнер. Эти бины выступают в роли связующего звена между представлением (View, `.xhtml` страница) и моделью/бизнес-логикой (Model/Controller).

Их называют "управляемыми", потому что фреймворк сам отвечает за их создание, инициализацию, помещение в нужный контекст (scope) и уничтожение.

---

## 1. Назначение управляемых бинов

Managed Beans выполняют несколько ключевых ролей в архитектуре MVC, которую реализует JSF:

1.  **Хранитель данных (Model)**: Бин содержит свойства (поля с геттерами и сеттерами), которые напрямую связываются с компонентами на странице с помощью Expression Language (EL).
    *   `value="#{userBean.firstName}"` — это связывание значения компонента `inputText` со свойством `firstName` в бине `userBean`.

2.  **Обработчик действий (Controller)**: Бин содержит методы, которые вызываются в ответ на действия пользователя (например, нажатие кнопки).
    *   `action="#{userBean.save}"` — это вызов метода `save()` в бине `userBean`.

3.  **Слушатель событий (Listener)**: Бин может содержать методы-слушатели для обработки различных событий JSF, таких как `ValueChangeEvent` или `ActionEvent`.

4.  **Мост к бизнес-логике**: Бин не должен содержать сложную бизнес-логику (например, прямые запросы к БД). Вместо этого он должен делегировать эти задачи сервисному слою (например, EJB или Spring-сервисам).

---

## 2. Способы конфигурации

Существует два основных способа объявить класс как управляемый бин: устаревший (XML) и современный (аннотации).

### 2.1. XML-конфигурация (устаревший способ)

В ранних версиях JSF (1.x) все бины нужно было вручную регистрировать в специальном файле `faces-config.xml`.

**Пример в `faces-config.xml`:**
```xml
<managed-bean>
    <managed-bean-name>userBean</managed-bean-name>
    <managed-bean-class>com.example.UserBean</managed-bean-class>
    <managed-bean-scope>request</managed-bean-scope>
</managed-bean>
````

Этот подход был многословным и неудобным. **Сегодня он не рекомендуется к использованию.**

### 2.2. Конфигурация через аннотации (современный стандарт)

Начиная с JSF 2.0, бины можно объявлять с помощью аннотаций прямо в Java-коде. Это делает код более чистым и наглядным.

**А) JSF-аннотации (устаревающий подход)**

Изначально в JSF 2.0 были введены свои аннотации.

- @ManagedBean из пакета javax.faces.bean
    
- Аннотации контекста: @RequestScoped, @ViewScoped, @SessionScoped, @ApplicationScoped из того же пакета.
    


```java
import javax.faces.bean.ManagedBean;
import javax.faces.bean.RequestScoped;

@ManagedBean(name="userBean") // Имя бина (по умолчанию - имя класса с маленькой буквы)
@RequestScoped
public class UserBean {
    // ... поля и методы
}
```

**Б) CDI-аннотации (рекомендуемый стандарт)**

Современные приложения на Jakarta EE используют **CDI (Contexts and Dependency Injection)** для управления бинами. CDI — это более мощный и универсальный стандарт, который отлично интегрируется с JSF.

- @Named из пакета javax.inject (или jakarta.inject).
- Аннотации контекста из пакета javax.enterprise.context (или jakarta.enterprise.context).


```java
import javax.inject.Named;
import javax.enterprise.context.RequestScoped;

@Named("userBean") // Имя бина для доступа из EL
@RequestScoped
public class UserBean {
    // ... поля и методы
}
```

**Почему CDI лучше?** CDI предоставляет полноценное внедрение зависимостей (@Inject), более строгую типизацию, поддержку событий, интерцепторов и декораторов. **Для всех новых проектов следует использовать CDI.**

---

## 3. Контекст (Scope) управляемых бинов

**Контекст (или область видимости)** — это самая важная характеристика бина. Она определяет, **как долго живет экземпляр бина** и для какого круга пользователей/запросов он доступен. Выбор неправильного контекста — одна из самых частых причин ошибок в JSF-приложениях.

|   |   |   |
|---|---|---|
|Аннотация (CDI)|Назначение и время жизни|Когда использовать?|
|**@RequestScoped**|**Один HTTP-запрос.** Бин создается в начале запроса и уничтожается в конце, после отправки ответа.|Для простых страниц и форм, где не нужно сохранять состояние между AJAX-запросами. Самый "безопасный" и легковесный контекст.|
|**@ViewScoped**|**Одна "вкладка" браузера.** Бин живет до тех пор, пока пользователь взаимодействует с одной и той же страницей (переходит по ссылкам на этой же странице или использует AJAX). Уничтожается при переходе на другую страницу.|**Идеально для страниц с AJAX.** Например, таблица с сортировкой/фильтрацией, где состояние (текущая страница, фильтры) должно сохраняться между AJAX-запросами.|
|**@SessionScoped**|**Одна пользовательская сессия.** Бин создается при первом обращении пользователя и живет до тех пор, пока сессия не истечет по таймауту или не будет аннулирована (logout).|Для данных, которые должны быть доступны на протяжении всего визита пользователя на сайт: информация о залогиненном пользователе, корзина в интернет-магазине.|
|**@ApplicationScoped**|**Все приложение.** Бин создается один раз при старте приложения и живет до его остановки. Является **синглтоном** для всех пользователей.|Для глобальных данных: настройки приложения, кэшированные справочники, счетчики. **Внимание!** Требует ручной синхронизации для обеспечения потокобезопасности.|
|**@ConversationScoped**|**Одна "беседа" (conversation).** Более сложный контекст, чем @SessionScoped, для реализации многошаговых процессов (мастеров, визардов). Жизненным циклом можно управлять программно.|Для процессов, которые охватывают несколько страниц, например, оформление заказа или сложная регистрация.|