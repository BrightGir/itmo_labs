## Обзор

REST API — это архитектурный стиль, по которому приложения общаются по HTTP: клиент отправляет запрос (GET /api/users для списка пользователей), сервер возвращает данные в JSON. В Jakarta EE это реализуется через JAX-RS (стандартная спецификация версии 4.0 в EE 11, релиз июнь 2025), которая определяет аннотации для маршрутизации и обработки. В Spring — через Spring Web MVC (версия 6.2 в 2025), с аннотациями @RestController и @GetMapping, интегрированными с Boot для авто-конфигурации.

JAX-RS — часть EE, работает в контейнерах (WildFly, Payara), обеспечивает portability (код запускается на любом EE-сервере без изменений). Spring Web — фреймворк, требует Boot для простоты, но привязан к Spring-экосистеме. Оба возвращают JSON через библиотеки (JSON-B в EE, Jackson в Spring). В 2025 JAX-RS 4.0 добавляет поддержку Java Records для responses и async с Virtual Threads, Spring Web — AOT-компиляцию для native.

## Реализация в Jakarta EE (JAX-RS)

JAX-RS — спецификация для REST: аннотации определяют пути и методы, контейнер (e.g., Jersey) обрабатывает запросы. Требует Java 17+, deploy в WAR. Нет авто-конфигурации — настраиваешь Application-класс.

**Шаги реализации**:

1. Добавьте зависимость: jakarta.ws.rs-api:4.0 в pom.xml (provided scope).
2. Создайте Application-класс для регистрации ресурсов: @ApplicationPath("/api").
3. Определите ресурс: @Path для класса/метода, @GET/@POST для HTTP-методов.
4. Инжект зависимостей: @Inject из CDI.
5. Обработка JSON: @Produces/@Consumes с MediaType.APPLICATION_JSON, используйте POJO (JSON-B сериализует).
6. Deploy WAR в контейнер (WildFly: bin/jboss-cli --connect --command=deploy app.war).
7. Тестирование: curl или Postman (e.g., GET [http://localhost:8080/api/users](http://localhost:8080/api/users)).

**Код примера** (ресурс для пользователей, с CDI-инжектом):

```java
import jakarta.ws.rs.*;  // JAX-RS аннотации
import jakarta.ws.rs.core.*;  // Response
import jakarta.inject.Inject;  // CDI
import java.util.List;

@Path("/users")  // Базовый путь: /api/users (если ApplicationPath("/api"))
@Produces(MediaType.APPLICATION_JSON)  // Все ответы JSON
@Consumes(MediaType.APPLICATION_JSON)  // Вход JSON
public class UserResource {
    
    @Inject  // Инжект сервиса (CDI)
    private UserService service;  // UserService — @ApplicationScoped с логикой
    
    @GET  // GET /users — список всех
    public List<User> getAll() {
        return service.findAll();  // Service возвращает List<User>, JSON-B — JSON
    }
    
    @GET
    @Path("/{id}")  // GET /users/{id} — один пользователь
    public Response getById(@PathParam("id") Long id) {  // @PathParam извлекает id из URL
        User user = service.findById(id);
        if (user == null) {
            return Response.status(Response.Status.NOT_FOUND).build();  // 404
        }
        return Response.ok(user).build();  // 200 + JSON
    }
    
    @POST  // POST /users — создание
    public Response create(User input) {  // @Consumes парсит JSON в User (POJO)
        User saved = service.save(input);
        return Response.status(Response.Status.CREATED).entity(saved).build();  // 201 + JSON
    }
}

// Application-класс для регистрации (META-INF/services/jakarta.ws.rs.core.Application)
@ApplicationPath("/api")  // Базовый /api
public class RestApp extends Application {
    @Override
    public Set<Class<?>> getClasses() {
        Set<Class<?>> classes = new HashSet<>();
        classes.add(UserResource.class);  // Регистрируй ресурсы
        return classes;
    }
}

// User — POJO для JSON
public class User {
    private Long id;
    private String name;
    // Геттеры/сеттеры (JSON-B использует их для сериализации)
}
```

- **Факты**: @PathParam/@QueryParam для параметров. ExceptionMapper для ошибок (e.g., NotFoundException → 404). В EE 11 JAX-RS 4.0: @RegisterRestApplication для CDI-авто-регистрации.

**Тестирование**: Deploy, GET [http://localhost:8080/api/users/1](http://localhost:8080/api/users/1) — {"id":1,"name":"Alice"}. POST JSON {"name":"Bob"} — 201 с saved.

## Реализация в Spring (Web MVC)

Spring Web MVC — фреймворк для REST: @RestController определяет эндпоинты, Boot auto-конфигурует сервер (Tomcat) и Jackson для JSON. Требует Java 17+, запускается JAR.

**Шаги реализации**:

1. Добавьте spring-boot-starter-web в pom.xml.
2. @RestController для класса, @RequestMapping/@GetMapping для методов.
3. Инжект: @Autowired из Spring DI.
4. Обработка JSON: Авто через Jackson (POJO → JSON).
5. Запуск: mvn spring-boot:run.
6. Тестирование: curl или Postman.

**Код примера** (контроллер для пользователей, с Spring DI):


```java
import org.springframework.web.bind.annotation.*;  // Аннотации MVC
import org.springframework.http.*;  // ResponseEntity
import org.springframework.beans.factory.annotation.Autowired;  // DI
import java.util.List;

@RestController  // JSON по умолчанию
@RequestMapping("/api/users")  // Базовый путь
public class UserController {
    
    @Autowired  // Spring DI
    private UserService service;  // UserService — @Service с логикой
    
    @GetMapping  // GET /api/users — список
    public List<User> getAll() {
        return service.findAll();  // Jackson сериализует в JSON
    }
    
    @GetMapping("/{id}")  // GET /api/users/{id}
    public ResponseEntity<User> getById(@PathVariable Long id) {  // @PathVariable — id из URL
        User user = service.findById(id);
        if (user == null) {
            return ResponseEntity.notFound().build();  // 404
        }
        return ResponseEntity.ok(user);  // 200 + JSON
    }
    
    @PostMapping  // POST /api/users
    public ResponseEntity<User> create(@RequestBody User input) {  // @RequestBody — JSON в User
        User saved = service.save(input);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);  // 201 + JSON
    }
}

// User — POJO для JSON
public class User {
    private Long id;
    private String name;
    // Геттеры/сеттеры (Jackson использует их)
}

// Main для Boot
@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);  // Авто-запуск
    }
}
```

- **Факты**: @RequestBody/@ResponseBody для JSON. ExceptionHandler для ошибок. В Spring 6.2: @RestControllerAdvice для global ошибок.

**Тестирование**: Run, GET [http://localhost:8080/api/users/1](http://localhost:8080/api/users/1) — {"id":1,"name":"Alice"}. POST JSON — 201.

## Сходства и отличия

**Сходства**:

- Аннотации для маршрутизации (@Path ≈ @RequestMapping, @GET ≈ @GetMapping).
- DI (@Inject ≈ @Autowired).
- JSON из POJO (MediaType.APPLICATION_JSON ≈ auto в Spring).
- Response для статусов (Response.status(404) ≈ ResponseEntity.notFound()).
- Факты: Оба основаны на HTTP, поддерживают async (CompletableFuture в 2025).

**Отличия**:

|Аспект|JAX-RS (EE)|Spring Web|
|---|---|---|
|**Конфигурация**|Application-класс для регистрации, beans.xml для CDI.|Boot auto (yml), @SpringBootApplication.|
|**JSON**|JSON-B (стандарт EE).|Jackson (настраиваемо).|
|**Ошибки**|ExceptionMapper.|@ExceptionHandler или @ControllerAdvice.|
|**Запуск**|Deploy WAR в контейнер.|mvn run (embedded).|
|**Факты**|Portability (TCK-тесты).|Гибкость (interceptors).|

**Итог**: JAX-RS — стандартный (мигрируй между серверами), Spring Web — удобный (auto в Boot). Код похож, различия в конфиге/запуске. В 2025 оба с Virtual Threads для async.