Транзакция — это "атомарная операция": либо всё прошло идеально (все шаги удались), либо ничего не изменилось (откат). В Jakarta EE (EE 11, 2025) транзакции — ключ к надёжности: без них в большом приложении (e.g., магазин) может быть хаос, если один шаг сломается (оплата прошла, но товар не списался).

Управление: Авто (контейнер решает) или ручное. JTA — стандартный API для этого в EE. Всё в Full Profile, работает с EJB/CDI/JPA. Зачем? Чтобы данные consistent, особенно с БД.

## Понятие транзакции: Что это такое

Транзакция — "пакет" операций, как банковский перевод: счёт A минус 100, счёт B плюс 100. Если минус удался, но плюс нет (БД упала) — откат всего, иначе потеря денег.

**Свойства (ACID)** — почему не сломается:

- **Atomicity (атомарность)**: Всё или ничего. Аналогия: Ты в магазине — платишь и берёшь товар. Если касса сломалась — ничего не берёшь.
- **Consistency (согласованность)**: После транзакции данные в порядке (e.g., баланс >0). В БД: правила (constraints) соблюдаются.
- **Isolation (изоляция)**: Твоя транзакция не мешает другим (e.g., другой перевод не видит "полуготовый" минус).
- **Durability (долговечность)**: После commit — данные сохранены навсегда (даже если сервер упал).

**В жизни**: Без ACID — хаос: в банке деньги "испаряются". В EE: Транзакция охватывает EJB-метод или JPA-save.

**Проблемы без транзакций**: Race condition (два перевода — минус 200, но плюс 100), dirty read (видишь некоммитнутые изменения).

## Управление транзакциями в Jakarta EE

В EE два подхода: **CMT (Container-Managed Transactions)** — контейнер (WildFly) сам начинает/заканчивает транзакцию (проще). **BMT (Bean-Managed Transactions)** — ты вручную (UserTransaction, для сложных случаев).

**Таблица сравнения**:

|Тип|Как работает|Когда использовать|Плюсы/Минусы|
|---|---|---|---|
|**CMT**|Аннотации (@TransactionAttribute): REQUIRED (по умолчанию, используй текущую tx), REQUIRES_NEW (новая tx). Контейнер commit/rollback.|EJB-методы, простые операции.|+ Авто, tx в CDI/EJB. - Меньше контроля.|
|**BMT**|UserTransaction utx = ...; utx.begin(); ... utx.commit()/rollback().|Нестандартные (e.g., nested tx).|+ Гибкость. - Больше кода, ошибки.|

**В EE 11**: Поддержка Virtual Threads (Java 21) для tx без блокировки. Интеграция с JPA (EntityManager в tx).

**Код CMT** (в EJB, для перевода):

java

```java
@Stateless
public class BankService {
    @PersistenceContext  // JPA для БД
    private EntityManager em;
    
    @TransactionAttribute(TransactionAttributeType.REQUIRED)  // Default: используй tx
    public void transfer(String from, String to, double amount) {
        // Шаг 1: Минус с from
        Account accFrom = em.find(Account.class, from);
        accFrom.setBalance(accFrom.getBalance() - amount);
        em.merge(accFrom);
        
        // Шаг 2: Плюс to (если ошибка здесь — откат всего!)
        Account accTo = em.find(Account.class, to);
        accTo.setBalance(accTo.getBalance() + amount);
        em.merge(accTo);
        
        // Контейнер commit'ит (если OK) или rollback (если exception)
    }
}
```

- **Что происходит**: Если шаг 2 fail (e.g., БД ошибка) — минус отменяется. Пользователь видит "OK" или "ошибка".

**BMT пример** (ручной, в CDI-bean):


```java
@Inject private UserTransaction utx;  // Инжект из JTA

public void manualTransfer(String from, String to, double amount) {
    try {
        utx.begin();  // Начни tx
        // Шаги как выше...
        em.merge(accFrom);
        em.merge(accTo);
        utx.commit();  // Всё OK — сохрани
    } catch (Exception e) {
        utx.rollback();  // Откат
        // Лог
    }
}
```

## JTA: Что это и как работает

JTA (Jakarta Transactions API) — "дирижёр" транзакций в EE: стандарт для распределённых tx (несколько БД, JMS). Не спецификация сама, а API (jakarta.transaction.*) для CMT/BMT. В EE 11: Версия 2.0, с улучшениями для async.

**Роль**: Обеспечивает 2PC (two-phase commit) — для multi-resource (e.g., БД + JMS: сохрани заказ в БД и кинь в очередь атомарно).

**Компоненты**:

- **UserTransaction**: Для BMT (utx.begin/commit).
- **TransactionManager**: Внутренний, для контейнера (CMT).
- **XAResource**: Для 2PC (координация ресурсов).

**Пример с JMS + JPA** (атомарно: сохрани + кинь сообщение):


```java
@Stateless
public class OrderService {
    @TransactionAttribute(TransactionAttributeType.REQUIRED)  // JTA управляет
    public void placeOrder(Order order) {
        em.persist(order);  // Шаг 1: В БД
        
        // Шаг 2: В очередь (JMS)
        TextMessage msg = sess.createTextMessage(order.getId());
        producer.send(msg);
        
        // JTA: Если JMS fail — откат БД. 2PC: обе ресурса commit или rollback
    }
}
```

- **В жизни**: Заказ сохранён в БД И отправлен в очередь для доставки — или ничего.

**Конфиг**: В persistence.xml (JTA-data-source) или standalone.xml (WildFly).