Модули — это "кусочки" Spring, которые ты подключаешь только нужные, чтобы app не раздувалась. Не как в EE, где "всё по стандарту", а как в конструкторе: взял Web для сайта, Data для БД — готово. В Boot — starters (готовые пакеты), тянешь одной строкой в pom.xml.

**Ключевые модули с примерами**:

- **Core (основа)**: Управляет объектами (DI — "сам подставь репозиторий"). Аналогия: Авто-пилот — не пишешь new Repo, Spring сам. Используй всегда. Пример: В магазине сервис заказов "знает" про БД без кода.
- **Web/MVC**: Для API и страниц (@RestController — GET /products возвращает список товаров). Аналогия: Дверь в дом — запрос пришёл, ответ ушёл. Пример: Мобилка зовёт /orders — JSON с заказами.
- **Data**: Для БД (JPA — сохрани User в MySQL). Аналогия: Ящик для инструментов — auto-CRUD (создай/найди/обнови). Пример: findByName("Alice") — список без SQL.
- **Security**: Для логинов/ролей (hasRole("ADMIN")). Аналогия: Замок с ключами — только админ видит /admin. Пример: В банке /balance — логинь, иначе 401.
- **Boot**: "Стартер" — auto-конфиг, embedded сервер. Аналогия: Микроволновка — положил, нажал, готово. Пример: mvn run — сайт на localhost.

**Как выбрать**: Для простого API — Web + Boot. Для БД — + Data. В pom.xml: spring-boot-starter-web — тянет Core + Tomcat.

**Пример в жизни**: Стартап делает app для доставки — Core для DI, Web для API, Data для заказов в БД. Всё в 3 starters, код — 100 строк.

## Архитектура Spring Runtime: Как "двигатель" запускает app

Runtime — это "мозг" Spring: IoC-контейнер (ApplicationContext), который создаёт объекты, связывает их (DI) и управляет жизнью (init/cleanup). В Boot — auto: run() — и контекст готов, сервер запущен.

**Простая аналогия**: Контекст — как дирижёр оркестра: сканирует код (@Component — "ты игрок"), подставляет инструменты (@Autowired), начинает концерт (@PostConstruct).

**Как работает шаг за шагом**:

1. **Запуск**: SpringApplication.run(App.class) — читает yml (конфиг: порт, БД).
2. **Сканирование**: Ищет @Component — создаёт бины (UserService, Repo).
3. **DI**: @Autowired — связывает (UserService знает Repo).
4. **Lifecycle**: @PostConstruct — "готов, загрузи данные"; @PreDestroy — "убирайся".
5. **Runtime**: Сервер (Tomcat) ловит запросы, контекст отдаёт бины.

**Пример в жизни**: App для магазина — run() — контекст создаёт OrderService, инжектит Repo, Tomcat ждёт /orders. Запрос — сервис отвечает JSON.

**Код минимальный** (main + бин):


```java
@SpringBootApplication  // "Включи сканирование и auto-config"
public class ShopApp {
    public static void main(String[] args) {
        SpringApplication.run(ShopApp.class, args);  // Runtime старт: контекст + сервер
    }
}

@Component  // "Я бин"
class OrderService {
    @Autowired  // "Подставь Repo"
    private OrderRepo repo;
    
    @PostConstruct  // "После создания — инициализируйся"
    public void start() {
        System.out.println("Магазин открыт!");  // Загрузи кэш
    }
}
```

- **Что видишь**: Run — "Магазин открыт!", localhost:8080/orders — работает.

В 6.2: Runtime с AOT — компилирует заранее, быстрее в cloud.

## Spring Security: Как защитить app (логин, роли)

Security — "охранник": проверяет, кто заходит (auth), что может (роли). В Boot — auto: добавь starter, и /login готов.

**Аналогия**: Дверь с кодовым замком — ввёл пароль (auth), показал пропуск (роль ADMIN).

**Как настроить шаг за шагом**:

1. Добавь starter-security — auto-логин (user/password из консоли).
2. Конфиг: SecurityFilterChain — .authorizeHttpRequests() для путей.
3. Роли: hasRole("USER") — только для юзеров.
4. Для прод: БД или OAuth (Google login).

**Пример в жизни**: В app банка — /balance только после логина, /admin — для босса.

**Код** (защита /users — логин, /admin — роль):


```java
@Configuration
@EnableWebSecurity  // "Включи охрану"
public class Guard {
    
    @Bean  // Конфиг цепочки фильтров
    public SecurityFilterChain chain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(req -> req
            .requestMatchers("/public").permitAll()  // Без пароля
            .requestMatchers("/users").authenticated()  // Логинь любой
            .requestMatchers("/admin").hasRole("ADMIN")  // Только админ
            .anyRequest().denyAll()  // Остальное — стоп
        )
        .formLogin()  // Форма /login
        .logout();  // /logout
        return http.build();
    }
    
    @Bean  // Пользователи (в memory для теста)
    public UserDetailsService users() {
        return new InMemoryUserDetailsManager(
            User.withDefaultPasswordEncoder()
                .username("user").password("pass").roles("USER").build(),
            User.withDefaultPasswordEncoder()
                .username("admin").password("pass").roles("ADMIN").build()
        );
    }
}
```

- **Тести**: /users — редирект на /login. Логинь user/pass — OK. /admin — 403 без роли.

Для OAuth: .oauth2Login() — логинь Google.

## Spring Data: Как работать с БД без боли

Data — "помощник" для БД: абстрагирует SQL, даёт готовые методы (findAll, save). JPA для реляционных (MySQL), Mongo для NoSQL.

**Аналогия**: Не пишешь SQL руками — как Google: "найди по имени", и готово.

**Как использовать шаг за шагом**:

1. Добавь starter-data-jpa + driver (H2 для теста).
2. @Entity User — модель.
3. Interface extends JpaRepository — auto-CRUD + кастом (findByName).
4. @Service зовёт repo.

**Пример в жизни**: В магазине — repo.findById(orderId) — заказ из БД.

**Код** (репо + сервис):

```java
@Entity  // "Это таблица в БД"
public class Order {
    @Id @GeneratedValue
    private Long id;
    private String item;
    // геттеры
}

public interface OrderRepo extends JpaRepository<Order, Long> {  // "Авто-магия"
    
    // Готовые: findAll(), save(order)
    
    List<Order> findByItem(String item);  // Авто-SQL: SELECT * FROM order WHERE item=?
    
    @Query("SELECT o FROM Order o WHERE o.id = :id")  // Кастом JPQL
    Order findByIdCustom(@Param("id") Long id);
}

@Service
public class OrderService {
    @Autowired private OrderRepo repo;  // Инжект
    
    public List<Order> getByItem(String item) {
        return repo.findByItem(item);  // Вызов — БД вернёт список
    }
}
```

- **Тести**: yml: spring.datasource.url=jdbc:h2:mem:test. /orders/item=book — список.

Для Mongo: spring-boot-starter-data-mongodb, extends MongoRepository.

## Итог

Модули — "выбери инструмент" (Core + Web для API). Runtime — "дирижёр" (run — и app живой). Security — "замок" (логин/роли за 10 строк). Data — "волшебник БД" (findByName без SQL). В Boot — минимум усилий, в 6.2 — супер для cloud.