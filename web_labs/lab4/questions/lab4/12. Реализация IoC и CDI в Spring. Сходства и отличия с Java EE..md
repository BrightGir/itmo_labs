IoC (Inversion of Control, "инверсия контроля") — это идея, когда фреймворк сам создаёт и связывает твои объекты, а не ты вручную (new Repo()). CDI (Contexts and Dependency Injection) — спецификация EE для этого: управляет зависимостями и "жизнью" объектов (scopes, события).

В Spring IoC — сердце фреймворка (Core-модуль), CDI — не используется (Spring имеет свой DI). В EE CDI — стандарт (версия 4.0 в EE 11, 2025). Сходства: Оба решают "не пиши new". Отличия: Spring проще (магия Boot), EE строже (стандарты). В 2025 Spring 6.2 интегрирует Jakarta namespaces, так что код мигрирует легче.

**Аналогия**: IoC/CDI — как Uber: ты говоришь "куда", а приложение само едет (создаёт машину, связывает с водителем). Без — сам рулишь (new Driver()).

## IoC в Spring: Как это работает

Spring IoC — "контейнер" (ApplicationContext), который создаёт "бины" (твои классы), инжектит зависимости (@Autowired) и управляет ими. В Boot — auto: run() — и всё готово.

**Шаги на практике**:

1. Аннотируй класс @Component — "я бин, создай меня".
2. @Autowired — "подставь зависимость" (e.g., сервис знает репозиторий).
3. Контекст сканирует, создаёт, связывает.
4. Scopes: @Scope("singleton") — один экземпляр (default), prototype — новый каждый раз.

**Пример в жизни**: В магазине сервис заказов (@Service) знает про репозиторий (@Repository). Spring сам создаёт repo, подставляет в сервис — вызов service.save(order), и готово.

**Код** (простой сервис):

```java
@Component  // "Я бин, Spring создай"
public class OrderService {
    @Autowired  // "Подставь repo"
    private OrderRepo repo;  // OrderRepo — @Repository
    
    public void save(Order order) {
        repo.save(order);  // Spring связал, работает
    }
}

@SpringBootApplication  // Сканирует бины
public class App {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(App.class, args);  // IoC-контейнер готов
        OrderService service = context.getBean(OrderService.class);  // Возьми бин
        service.save(new Order());  // Всё связано
    }
}
```

- **Что происходит**: Run — Spring находит @Component, new OrderService, new OrderRepo, @Autowired — repo в service. Без IoC — new OrderRepo() вручную, тесная связь.

## CDI в Jakarta EE: Как это работает

CDI — стандарт EE для IoC: контейнер (Weld в WildFly) управляет "управляемыми бины" (@ApplicationScoped), инжектит (@Inject), scopes (@RequestScoped — на запрос).

**Шаги на практике**:

1. Аннотируй @ApplicationScoped — "управляй мной".
2. @Inject — "подставь зависимость".
3. Контейнер (при deploy) сканирует, создаёт, связывает.
4. Scopes: @Dependent — по запросу, @SessionScoped — на сессию.

**Пример в жизни**: Тот же магазин — сервис заказов (@ApplicationScoped) знает repo (@Repository). Контейнер сам связывает при deploy WAR.

**Код** (похожий):

java

```
@ApplicationScoped  // "Управляй мной"
public class OrderService {
    @Inject  // "Подставь repo"
    private OrderRepo repo;  // @Repository
  
    public void save(Order order) {
        repo.save(order);  // Связь готова
    }
}

// В EE — deploy WAR, контейнер (WildFly) запускает CDI
```

- **Что происходит**: Deploy — контейнер находит @ApplicationScoped, new OrderService, new OrderRepo, @Inject — repo в service. Без CDI — new вручную.

## Сходства: Где они похожи

Оба — IoC: фреймворк создаёт/связывает, ты не new. Код мигрирует (Spring поддерживает Jakarta @Inject).

**Простые сходства**:

- **DI**: @Autowired ≈ @Inject — подставь зависимость.
- **Бины**: @Component ≈ @ApplicationScoped — "создай меня".
- **Lifecycle**: @PostConstruct в Spring ≈ @PostConstruct в CDI — "инициализируйся после создания".
- **Scopes**: Singleton в Spring ≈ @ApplicationScoped в CDI — один на app.
- **Пример**: Сервис знает repo — в обоих 3 строки кода, работает одинаково.

**В жизни**: В магазине save(order) — Spring или EE сделают то же: repo.save().

## Отличия: Где Spring проще, EE строже

Spring — "умный помощник" (Boot угадывает), EE — "правила" (стандарт, контейнер управляет).

**Таблица отличий** (с примерами):

|Аспект|Spring IoC|CDI in EE|Пример / Когда выбрать|
|---|---|---|---|
|**Запуск**|Boot run() — auto-контекст.|Deploy WAR — контейнер (WildFly) запускает.|Spring — 1 команда для теста. EE — для сервера.|
|**Конфиг**|YAML, @Configuration — магия.|beans.xml — explicit (альтернативы, interceptors).|Spring — быстро. EE — контроль (для команды).|
|**Scopes**|@Scope("request") — гибко.|@RequestScoped — стандарт, прокси для доступа.|Spring — кастом. EE — portability (работает везде).|
|**События**|@EventListener — просто.|@Observes — CDI-события, async в 4.0.|Spring — для Boot. EE — для tx (JTA).|
|**Интеграция**|Boot starters — всё в одном.|Specs — мигрируй между серверами.|Spring — прототип. EE — enterprise.|

