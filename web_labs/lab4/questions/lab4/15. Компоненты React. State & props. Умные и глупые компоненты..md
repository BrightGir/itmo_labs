### 1. Компоненты React

**Основная идея:** React построен на **компонентах** – независимых, самодостаточных частях UI. Они являются строительными блоками любого React-приложения.

- **Что такое компонент?**
    
    - Функция или класс JavaScript, который возвращает React-элементы (обычно в виде JSX).
        
    - Представляет собой часть пользовательского интерфейса.
        
    - Может иметь свое собственное состояние и принимать свойства.
        
- **Виды компонентов:**
    
    - **Функциональные компоненты (Functional Components):**
        
        - Определяются как обычные JS-функции.
            
        - Используют хуки (useState, useEffect и т.д.) для управления состоянием и побочными эффектами.
            
        - Современный и предпочтительный способ создания компонентов.
            
        
    
        
        ```jsx
        function WelcomeMessage(props) {
          return <h1>Привет, {props.name}!</h1>;
        }
        ```
        
    - **Классовые компоненты (Class Components):**
        
        - Определяются как классы ES6, наследующие от React.Component.
            
        - Имеют свой собственный state и методы жизненного цикла.
            
        - Более старый подход, встречается в легаси-коде.
            
        

        
        ```jsx
        class WelcomeMessage extends React.Component {
          render() {
            return <h1>Привет, {this.props.name}!</h1>;
          }
        }
        ```
        
- **JSX:** Часто используется для описания структуры компонента, делая код более читаемым.
    

---

### 2. State (Состояние)

**State** – это данные, которыми **управляет сам компонент**. Они могут меняться со временем, и при изменении state React автоматически обновляет UI.

- **Назначение:** Хранение динамических данных, которые влияют на рендеринг компонента.
    
- **Изменение state:**
    
    - **Функциональные компоненты:** Используется хук useState.
        
        
        ```jsx
        import React, { useState } from 'react';
        
        function Counter() {
          const [count, setCount] = useState(0); // count - текущее значение, setCount - функция для его изменения
        
          return (
            <div>
              <p>Счетчик: {count}</p>
              <button onClick={() => setCount(count + 1)}>Увеличить</button>
            </div>
          );
        }
        ```
        
    - **Классовые компоненты:** Используется this.state и метод this.setState().
        
        
        ```jsx
        class Counter extends React.Component {
          constructor(props) {
            super(props);
            this.state = { count: 0 };
          }
        
          render() {
            return (
              <div>
                <p>Счетчик: {this.state.count}</p>
                <button onClick={() => this.setState({ count: this.state.count + 1 })}>Увеличить</button>
              </div>
            );
          }
        }
        ```
        
- **Правила:**
    
    - state должен быть иммутабельным (неизменяемым). Всегда создавайте новый объект/массив при обновлении, а не модифицируйте существующий.
        
    - Изменение state должно происходить только через специальные функции (setCount, this.setState).
        

---

### 3. Props (Свойства)

**Props** – это данные, которые **передаются в компонент извне** (от родительского компонента). Они позволяют компонентам быть настраиваемыми и повторно используемыми.

- **Назначение:** Передача данных от родителя к потомку. Настройка внешнего вида и поведения дочернего компонента.
    
- **Передача Props:**
    
    ```jsx
    // Родительский компонент
    function App() {
      return <Greeting name="Alice" age={30} />;
    }
    
    // Дочерний компонент
    function Greeting(props) { // props - это объект, содержащий все переданные свойства
      return (
        <p>Привет, {props.name}! Тебе {props.age} лет.</p>
      );
    }
    ```
    
- **Правила:**
    
    - **Read-only:** Компонент не должен изменять props. Они предназначены только для чтения. Если нужно изменить значение, которое пришло через props, нужно управлять им в state родительского компонента и передавать новое значение обратно (или через колбэк-функции).
        
    - **Типы Props:** Могут быть любого типа данных: строки, числа, булевы значения, объекты, массивы, функции, другие React-элементы.
        

---

### 4. "Умные" и "Глупые" Компоненты (Container/Presentational Components)

Это паттерн проектирования, предложенный Стивом Смитом (Dan Abramov), который помогает лучше структурировать React-приложения, разделяя логику данных и представление.

#### 4.1. "Глупые" Компоненты (Presentational Components)

- **Что это:** Компоненты, которые отвечают **только за отображение UI**.
    
- **Характеристики:**
    
    - Не имеют собственного state (или имеют минимальный state для UI-элементов, например, состояние "hover" кнопки).
        
    - Получают все необходимые данные через props.
        
    - Используют props для отображения информации.
        
    - Могут передавать колбэк-функции (полученные через props) для обработки событий (например, onClick={props.onButtonClick}).
        
    - Легко переиспользуются.
        
    - Часто являются функциональными компонентами.
        
- **Пример:** Компонент Button, UserProfileInfo, ProductCard (отображает данные, но не управляет ими).
    

#### 4.2. "Умные" Компоненты (Container Components)

- **Что это:** Компоненты, которые отвечают за **логику приложения, управление данными и state**.
    
- **Характеристики:**
    
    - Имеют state.
        
    - Загружают данные (например, через API).
        
    - Управляют state и передают данные вниз к "глупым" компонентам через props.
        
    - Могут содержать колбэк-функции, которые потом передают в "глупые" компоненты для обработки событий.
        
    - Часто не имеют собственного HTML-разметки (или имеют минимальную, оберточную).
        
    - Обычно находятся выше в иерархии компонентов.
        
- **Пример:** Компонент, который загружает список пользователей с сервера и передает этот список в "глупый" компонент UserList, а также обрабатывает события клика на пользователя, передавая ID в колбэк-функцию.
    

#### **Преимущества паттерна Container/Presentational:**

- **Разделение ответственности:** Четко разделяет логику данных и представление, делая код более чистым и поддерживаемым.
    
- **Переиспользование:** "Глупые" компоненты можно легко использовать в разных "умных" компонентах.
    
- **Тестируемость:** "Умные" компоненты легко тестировать, имитируя их state и props. "Глупые" компоненты легко тестировать, проверяя, как они рендерят данные из props.
    
- **Улучшенная структура:** Приложение становится более организованным.
    

**Важное замечание:** С появлением хуков (особенно useState, useEffect, useContext), граница между "умными" и "глупыми" компонентами может стать менее явной. "Глупые" компоненты теперь могут использовать хуки для своего внутреннего UI-состояния, но основная идея разделения ответственности остается актуальной. Компоненты, которые управляют загрузкой данных и бизнес-логикой, по-прежнему можно считать "умными".

---