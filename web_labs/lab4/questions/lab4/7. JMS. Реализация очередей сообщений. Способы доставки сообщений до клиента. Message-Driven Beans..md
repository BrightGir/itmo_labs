JMS — это "почтовая служба" для программ в Java EE. Вместо того чтобы один сервис звонил другому и ждал ответа (и всё зависало, если второй тормозит), ты кидаешь "письмо" (сообщение) в общую "почту" (очередь или топик). Другой сервис берёт его, когда готов, и отвечает "принято".

**Зачем в реале?**

- **Магазин онлайн**: Пользователь кликнул "купить" — фронт сразу говорит "заказ принят", а обработку (оплата, склад) кидает в очередь. Сайт не тормозит, даже если банк медленный.
- **Банк**: Ты перевёл деньги — app сразу показывает "OK", а уведомление (SMS, email) уходит в топик, и все устройства получают копию. Если телефон выключен — сообщение подождёт.
- **Игра**: Игрок написал в чат — сообщение в топик, все в комнате видят мгновенно, без "подвисаний".

Без JMS всё синхронно: один шаг — и вся система стоп. JMS — асинхронно, надёжно, не теряет данные. В EE 11 (2025) оно проще: меньше кода, работает с твоими EJB/CDI.

## Очереди сообщений: Как это работает на практике

"Почта" — это брокер (типа ActiveMQ, запусти в Docker за минуту). Два вида "ящиков":

**Очередь (как очередь в кассу)**: Один отправитель кладёт задачу, один обработчик берёт (по порядку). Сообщение исчезает после обработки.

- **Пример**: В магазине заказ в очередь — один worker (сервис) берёт, платит, упаковывает. Если worker сломается — сообщение вернётся, не потеряется.
- **Как сделать**: Настрой брокер, в коде укажи @Resource Queue. Отправь producer.send(msg).

**Топик (как рассылка в WhatsApp-группе)**: Отправитель шлёт, все подписчики получают копию. Сообщение не исчезает.

- **Пример**: В банке "новый курс валют" — топик рассылает всем apps (веб, мобилка). Если мобилка off — durable (сохранит).
- **Как сделать**: Замени Queue на Topic, создай подписчика.

**Код отправки заказа (в простом сервисе)**:


```java
// В твоём контроллере (EJB или CDI)
@Resource private Queue orderQueue;  // "Ящик" для заказов (настрой в сервере)
@Resource private ConnectionFactory cf;  // Фабрика "почты"

public void handleBuy(String orderId) {
    try {
        // Подключись к почте
        Connection conn = cf.createConnection();
        conn.start();  // "Включи приём"
        Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);  // "Авто-подтверждение"
        
        // Создай отправителя и письмо
        MessageProducer sender = sess.createProducer(orderQueue);
        TextMessage letter = sess.createTextMessage("Обработай заказ: " + orderId);
        
        sender.send(letter);  // Кинул в очередь
        
        // Закрой
        sess.close();
        conn.close();
        
        return "Заказ в работе!";  // Фронт отвечает сразу
    } catch (Exception e) {
        return "Ошибка, попробуй позже";  // Без паники
    }
}
```

- **В жизни**: Пользователь видит "принято" за 0.1 сек, обработка — через 5 мин.

## Как доставить сообщение клиенту: Sync или Async

"Доставка" — как получить письмо. Sync: сам иди за ним. Async: оно приходит само.

**Sync (сам жди, как проверка почты)**:

- **Пример**: Worker каждую минуту спрашивает "есть заказы?" — просто, но тратит время на пустые проверки.
- **Код** (в сервисе обработки):

java

```java
// ... conn, sess
MessageConsumer checker = sess.createConsumer(orderQueue);
TextMessage letter = (TextMessage) checker.receive(5000);  // Жди 5 сек
if (letter != null) {
    String orderId = letter.getText();
    // Обработай: оплати, сохрани
    System.out.println("Заказ " + orderId + " готов!");
}
```

- **Когда**: Для тестов или редких задач.

**Async (приходит само, как пуш в Telegram)**:

- **Пример**: В чате — сообщение падает сразу, без "обнови страницу".
- **Код**:


```java
MessageConsumer checker = sess.createConsumer(orderQueue);
checker.setMessageListener(msg -> {  // "Слушатель"
    if (msg instanceof TextMessage) {
        String orderId = ((TextMessage) msg).getText();
        // Обработай мгновенно
        System.out.println("Заказ " + orderId + " в работе!");
    }
});
conn.start();  // "Включи уведомления"
```

- **Когда**: Везде, где скорость важна.

## Message-Driven Beans: Автоматический обработчик

MDB — "робот-почтальон": EJB, который сам слушает очередь и обрабатывает. Контейнер (WildFly) создаёт несколько копий для нагрузки, добавляет транзакции (если ошибка — откат).

**Пример**: MDB для заказов в магазине — берёт из очереди, сохраняет, шлёт email.

- **Код** (разверни — и готово):

java

```java
@MessageDriven(  // "Я слушатель очереди"
    activationConfig = {
        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "jakarta.jms.Queue"),  // Тип
        @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = "java:/jms/queue/OrderQueue")  // Какая очередь
    }
)
public class OrderRobot implements MessageListener {  // "Слушатель"
    
    @Inject private OrderSaver saver;  // Твоя логика (CDI)
    @Inject private EmailSender mailer;  // Инжект email
    
    @Override
    public void onMessage(Message msg) {  // Авто-вызов при письме
        if (msg instanceof TextMessage) {
            String orderId = ((TextMessage) msg).getText();
            saver.saveToDB(orderId);  // Сохрани
            mailer.send("Заказ " + orderId + " готов!");  // Уведоми
            System.out.println("Робот обработал: " + orderId);
        }
        // Если ошибка — контейнер откатит, сообщение вернётся
    }
}
```

- **В жизни**: Разверни в WildFly — отправь заказ, робот возьмёт сам. Масштаб: 100 заказов/сек — пул роботов справится.