
В контексте Jakarta EE (ранее Java EE) принципы **Inversion of Control (IoC)**, **Contexts and Dependency Injection (CDI)** и **Location Transparency** являются фундаментальными для создания модульных, тестируемых и масштабируемых enterprise-приложений. Они помогают отделить бизнес-логику от инфраструктуры, обеспечивая гибкость и переносимость кода.

- **IoC**: Общий принцип, где контроль над созданием и управлением объектами передается фреймворку, а не разработчику.
- **CDI**: Конкретная спецификация Jakarta EE для реализации IoC через dependency injection и управление контекстами жизненного цикла.
- **Location Transparency**: Принцип, позволяющий компонентам работать независимо от их физического расположения (локально или удаленно).

Эти концепции тесно связаны с **компонентами** (модульными единицами кода) и **контейнерами** (runtime-средами, управляющими ими). В Jakarta EE 11 (актуальная версия на октябрь 2025) CDI 4.0 усиливает интеграцию с другими спецификациями, такими как EJB и JPA.

## Принцип Inversion of Control (IoC)

IoC — это паттерн проектирования, где вместо того чтобы объекты сами создавали свои зависимости (например, new Object()), фреймворк (контейнер) берет на себя управление жизненным циклом объектов и их связями. Это "инверсия контроля" — от разработчика к контейнеру.

### Ключевые аспекты

- **Проблема без IoC**: Жесткие зависимости (tight coupling) приводят к трудно тестируемому коду. Пример: класс UserService напрямую создает DatabaseConnection — меняя БД, нужно переписывать сервис.
- **Решение с IoC**: Зависимости "инжектируются" извне. Фреймворк управляет scope (областью видимости), lifecycle (создание/уничтожение) и конфигурацией.
- **Типы IoC**:
    - **Dependency Injection (DI)**: Зависимости передаются через конструктор, setter или поле.
    - **Dependency Lookup**: Объекты запрашивают зависимости у контейнера (реже в EE, больше в Spring).
    - **Event-driven**: События управляют взаимодействием (в CDI через @Observes).

### Преимущества

- **Тестируемость**: Легко подменять моки в unit-тестах.
- **Модульность**: Компоненты переиспользуемы.
- **Масштабируемость**: Контейнер распределяет нагрузку.

### Пример кода (простой DI без CDI)

java

```
// Без IoC: tight coupling
public class UserService {
    private DatabaseConnection db = new DatabaseConnection(); // Жесткая зависимость
}

// С IoC (ручной DI)
public class UserService {
    private DatabaseConnection db;
    
    public UserService(DatabaseConnection db) { // Конструктор-инъекция
        this.db = db;
    }
}
```

В Jakarta EE IoC реализуется через CDI или EJB, где контейнер автоматически инжектирует зависимости.

## Contexts and Dependency Injection (CDI)

CDI — спецификация Jakarta EE (версия 4.0 в EE 11), стандартизирующая IoC для managed beans. Она определяет, как контейнер управляет зависимостями и контекстами (scopes). CDI интегрируется со всеми другими спецификациями EE, делая его "клеем" платформы.

### Основные принципы CDI

- **Managed Beans**: Любые POJO с аннотациями (@ApplicationScoped, @Dependent) становятся управляемыми контейнером.
- **Dependency Injection**: Автоматическая инъекция через @Inject. Поддержка qualifiers (@Named, @Qualifier) для разрешения неоднозначностей.
- **Contexts (Scopes)**: Контексты определяют lifecycle bean'а. Контейнер создает прокси для доступа к bean'ам в разных scopes.
- **Events и Interceptors**: Асинхронные события (@Observes) и перехватчики (@Interceptor) для AOP-подобного поведения.
- **Producer/Disposer**: @Produces для динамического создания bean'ов, @Disposes для cleanup.

### Типы Scopes в CDI 4.0

|Scope|Описание|Lifecycle|Пример использования|
|---|---|---|---|
|**@Dependent**|Зависим от инжектирующего bean'а (default).|По запросу|Временные объекты, как validators.|
|**@RequestScoped**|Живет в рамках HTTP-запроса (Servlet).|Per-request|Данные формы в JSF.|
|**@SessionScoped**|Живет в сессии пользователя.|Per-session|Корзина покупок.|
|**@ApplicationScoped**|Singleton на всю аппликацию.|App-wide|Кэш конфигурации.|
|**@ConversationScoped**|Долгий разговор (long-running).|Per-conversation|Многошаговые формы.|
|**@Singleton**|Единственный экземпляр (EJB-like).|App-wide|Глобальный сервис.|
|**@Pseudoscope** (новое в 4.0)|Кастомные scopes для Virtual Threads.|Custom|Async задачи в Java 21.|

### Пример кода CDI

```
// Qualifier для разрешения зависимостей
@Qualifier
@Target({FIELD, PARAMETER})
@Retention(RUNTIME)
public @interface Development {}

@Development
public class DevDatabaseConnection implements DatabaseConnection { ... }

// Producer
public class DatabaseProducer {
    @Produces
    @Development
    public DatabaseConnection devConnection() { return new DevDatabaseConnection(); }
}

// Consumer (инъекция)
@ApplicationScoped
public class UserService {
    @Inject @Development
    private DatabaseConnection db;  // Авто-инъекция
    
    public void saveUser(User user) {
        db.save(user);  // IoC в действии
    }
}
```



**Активация**: В beans.xml (META-INF/beans.xml) указать \<alternatives\> или \<stereotypes\>.

### Нововведения в CDI 4.0 (EE 11)

- Поддержка Java Records и Virtual Threads для async DI.
- Улучшенная интеграция с Jakarta Data и Security.
- Async events для reactive programming.

## Location Transparency

Location Transparency — принцип, при котором компоненты взаимодействуют так, будто они локальные, независимо от физического расположения (JVM, сервер, сеть). В Jakarta EE это достигается через прокси и stubs, скрывающие детали распределения.

### Ключевые аспекты

- **Прозрачность**: Клиент вызывает метод локально, контейнер решает, где исполнить (локально/удаленно).
- **Реализация в EE**:
    - **EJB**: Remote interfaces — прокси перенаправляют вызовы по RMI/IIOP.
    - **CDI + Portable Extensions**: Beans могут быть проксированы для распределения.
    - **JMS/Web Services**: Асинхронные вызовы через messaging или REST/SOAP.
- **Преимущества**: Легкое масштабирование (миграция на кластер), отказоустойчивость.
- **Ограничения**: Latency в сети, сериализация объектов (требует Serializable).

### Пример в EJB (с CDI)

java

```
// Remote interface (прозрачный)
@Remote
public interface UserServiceRemote {
    void saveUser(User user);
}

// EJB-имплементация
@Stateless
public class UserService implements UserServiceRemote {
    @Inject private DatabaseConnection db;  // CDI-инъекция
    
    @Override
    public void saveUser(User user) {
        db.save(user);
    }
}

// Клиент (локальный или удаленный вызов одинаков)
@EJB private UserServiceRemote service;  // Прокси скрывает location
service.saveUser(new User());  // Прозрачно!
```

## Компоненты в Jakarta EE

Компоненты — это модульные, управляемые единицы кода с четко определенным lifecycle и интерфейсами. Контейнер управляет ими через аннотации.

### Типы компонентов

|Тип|Спецификация|Описание|Аннотации|Пример|
|---|---|---|---|---|
|**Managed Beans**|CDI|POJO с DI и scopes.|@ApplicationScoped|Сервисы с @Inject.|
|**Enterprise JavaBeans (EJB)**|EJB 4.0|Для транзакций и распределения.|@Stateless, @Stateful|Бизнес-логика с @Transaction.|
|**Servlets/Filters**|Servlet 6.0|Веб-компоненты.|@WebServlet|Обработка запросов.|
|**JSF Managed Beans**|JSF 4.0|UI-компоненты.|@Named (CDI)|Контроллеры страниц.|
|**REST Resources**|JAX-RS 3.1|API-эндпоинты.|@Path|REST-сервисы.|
|**Message-Driven Beans**|JMS 3.1|Асинхронные.|@MessageDriven|Обработка очередей.|

- **Lifecycle**: @PostConstruct (init), @PreDestroy (cleanup). Контейнер вызывает автоматически.

## Контейнеры в Jakarta EE

Контейнеры — runtime-среды, реализующие спецификации. Они управляют компонентами, обеспечивая IoC, pooling, security и т.д.

### Типы контейнеров

|Тип|Описание|Поддержка|Пример реализации|
|---|---|---|---|
|**Bean Container**|Управляет CDI-beans (DI, scopes).|CDI 4.0|Weld (в WildFly, GlassFish).|
|**EJB Container**|Для EJB: транзакции, pooling.|EJB 4.0|OpenEJB (в TomEE).|
|**Web Container**|Для Servlet/JSF.|Servlet 6.0|Tomcat (в TomEE), Undertow (WildFly).|
|**Persistence Context**|Для JPA.|JPA 3.1|Hibernate (WildFly).|
|**Application Client Container**|Для клиентских apps.|EE Platform|GlassFish ACC.|

- **Иерархия**: Контейнеры вложены (Web внутри EJB). В микросервисах — легковесные (Quarkus CDI-container).
- **Управление**: Через CDI portable extensions для кастомизации.

### Пример развертывания

В WildFly: Развернуть WAR с beans.xml — контейнер сканирует и активирует компоненты.

## Заключение и рекомендации для изучения

IoC, CDI и Location Transparency делают Jakarta EE мощной для enterprise: от простых DI до распределенных систем. Связь: CDI реализует IoC, а Location Transparency использует контейнеры для прозрачности.