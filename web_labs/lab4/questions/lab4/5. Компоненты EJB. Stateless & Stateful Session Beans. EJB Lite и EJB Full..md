## Обзор

Enterprise JavaBeans (EJB) — спецификация Jakarta EE (версия 4.0 в EE 11, октябрь 2025) для создания бизнес-компонентов с поддержкой транзакций, concurrency, security и распределения. EJB-компоненты — это POJO с аннотациями, управляемые контейнером (EJB Container), который обеспечивает lifecycle, pooling и DI (через CDI).

Основные компоненты: Session Beans (Stateless/Stateful), Message-Driven Beans (MDB). Фокус на Session Beans — для бизнес-логики. EJB упрощен в EE 11: меньше boilerplate, интеграция с CDI и Virtual Threads. Развертывание в WAR/EAR; portability через TCK.

## Компоненты EJB: Основы

EJB-компоненты реализуют интерфейсы (local/remote) и аннотированы для контейнера. Контейнер управляет:

- **Lifecycle**: @PostConstruct/@PreDestroy, pooling.
- **Транзакции**: @TransactionAttribute (REQUIRED, SUPPORTS и т.д.).
- **Security**: @RolesAllowed.
- **Concurrency**: @Lock (READ/WRITE).

Типы компонентов:

|Тип|Описание|Когда использовать|
|---|---|---|
|**Session Beans**|Синхронная бизнес-логика.|Сервисы, обработка запросов.|
|**Message-Driven Beans**|Асинхронная (JMS).|Обработка сообщений из очередей.|
|**Singleton Beans**|Singleton с @Singleton.|Глобальные сервисы (e.g., кэш).|

Пример базового EJB:

java

```
@Stateless  // Аннотация для контейнера
@Local(UserServiceLocal.class)  // Local интерфейс
public class UserServiceImpl implements UserServiceLocal {
    @Inject private UserRepository repo;  // CDI DI
    
    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void save(User user) {
        repo.persist(user);  // Бизнес-метод с tx
    }
}
```

## Stateless Session Beans

Stateless Session Beans (@Stateless) — "без состояния": не хранят данные между вызовами. Идеальны для масштабируемых сервисов. Контейнер использует пул экземпляров: берет из пула, выполняет метод, возвращает.

### Ключевые фичи

- **Pooling**: Экземпляры переиспользуются; нет passivation.
- **Concurrency**: По умолчанию READ (множественные вызовы параллельно).
- **Remote/Local**: Поддержка распределения (RMI).
- **Преимущества**: Высокая производительность, легкий кластеринг.

| Аспект                   | Детали                                                                |
| ------------------------ | --------------------------------------------------------------------- |
| **Lifecycle**            | Создание в пуле; @PostConstruct на allocation, @PreDestroy на return. |
| **Состояние**            | Нет; каждый вызов — чистый.                                           |
| **Пример использования** | Обработка заказов: stateless, так как не помнит предыдущие.           |

**Код-пример**:

java

```
@Stateless
@Lock(LockType.READ)  // Разрешает параллельные чтения
public class OrderProcessor {
    
    @PostConstruct
    public void init() { /* Setup */ }
    
    public Order process(Order order) {
        // Логика без хранения состояния
        return order.calculateTotal();
    }
    
    @PreDestroy
    public void cleanup() { /* Release */ }
}
```

Вызов: @EJB private OrderProcessor processor; processor.process(new Order());

## Stateful Session Beans

Stateful Session Beans (@Stateful) — "с состоянием": хранят данные между вызовами (conversation-like). Подходят для сессий пользователя. Контейнер управляет одним экземпляром на клиент, с passivation (сериализация в БД при неактивности).

### Ключевые фичи

- **Состояние**: Поля сохраняются; привязка к клиенту (affinity).
- **Passivation/Activation**: @PrePassivate/@PostActivate для save/restore.
- **Concurrency**: По умолчанию WRITE (один поток за раз).
- **Преимущества**: Для long-running процессов; но тяжелее stateless.

|Аспект|Детали|
|---|---|
|**Lifecycle**|Создание per-client; passivation при таймауте, destroy на @Remove.|
|**Состояние**|Хранится в полях; клиент-specific.|
|**Пример использования**|Корзина покупок: помнит добавленные товары.|

**Код-пример**:

java

```
@Stateful
@Local(ShoppingCartLocal.class)
public class ShoppingCartBean implements ShoppingCartLocal {
    private List<Item> cart = new ArrayList<>();  // Состояние
    
    @PostActivate
    public void activate() { /* Restore */ }
    
    public void addItem(Item item) {
        cart.add(item);  // Сохраняет состояние
    }
    
    @Remove  // Завершает сессию
    public void checkout() {
        // Process cart
        cart.clear();
    }
    
    @PrePassivate
    public void passivate() { /* Save state */ }
}
```

Вызов: @EJB private ShoppingCartLocal cart; cart.addItem(item); (состояние сохраняется).

## EJB Lite и EJB Full

EJB Lite — упрощенная версия (в Web Profile), без "тяжелых" фич. EJB Full — полный набор (в Full Platform). Выбор по профилю: Lite для веб/микросервисов, Full для enterprise.

### Сравнение

|Аспект|EJB Lite|EJB Full|
|---|---|---|
|**Доступные бины**|Stateless, Singleton, MDB (ограничено).|Все: + Stateful, Remote.|
|**Транзакции**|CMT (container-managed), базовые.|+ BMT (bean-managed), JTA.|
|**Распределение**|Только local.|Local + remote (RMI/IIOP).|
|**Профиль**|Web/Core.|Full.|
|**Использование**|Легковесные apps (TomEE).|Монолиты (WildFly).|
|**EE 11 изменения**|Улучшена интеграция с CDI; Virtual Threads в Lite.|Полная поддержка Concurrency 3.0.|

- **Lite**: Нет Stateful, remote; но 90% фич для большинства случаев.
- **Миграция**: Аннотации совместимы; проверь TCK.

## Итог

EJB — для надежной бизнес-логики: Stateless для скорости, Stateful для сессий. Lite хватит для простоты, Full — для legacy/распределения. В EE 11 EJB интегрируется с CDI, снижая код.