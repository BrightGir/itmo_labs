## Обзор

В Jakarta EE контейнер управляет жизненным циклом компонентов (beans, EJB, servlets) автоматически: от создания до уничтожения, включая DI и scopes. Это реализует IoC и обеспечивает resource management. Дескрипторы развертывания (XML-файлы) — метаданные для конфигурации на deploy, с фокусом на portability. В EE 11 (октябрь 2025) приоритет аннотациям, но XML для overrides и legacy.

## Жизненный цикл компонентов

Контейнер (Weld для CDI, OpenEJB для EJB) сканирует аннотации/дескрипторы на deploy, управляет instantiation, DI, invocation и cleanup. Фазы зависят от типа и scope (CDI 4.0).

### Основные фазы

1. **Instantiation**: Создание экземпляра (lazy/eager по scope). DI через @Inject.
2. **Initialization**: @PostConstruct после DI — для setup (e.g., load config).
3. **Invocation**: Бизнес-методы в контексте scope. Interceptors применяются.
4. **Destruction**: @PreDestroy перед GC или scope-end — для cleanup (e.g., close connections).

Scopes влияют: @Dependent — per-injection; @RequestScoped — per-HTTP; @ApplicationScoped — app-wide singleton.

Таблица по типам (EE 11 фичи):

|Тип|Фаза init|Фаза destroy|Особенности|Пример|
|---|---|---|---|---|
|**CDI Bean**|@PostConstruct|@PreDestroy|Async support (Virtual Threads)|@ApplicationScoped: init на startup.|
|**EJB Stateless**|@PostConstruct (post-pool)|@PreDestroy (pre-pool return)|Pooling, no passivation.|@Stateless: methods from pool.|
|**Servlet**|init()|destroy()|Per-request service().|@WebServlet: load-on-startup=1 для eager.|
|**MDB**|@PostConstruct|@PreDestroy|Async onMessage().|JMS activation on queue bind.|

**Код-пример (CDI @ApplicationScoped)**:

java

```
@ApplicationScoped
public class UserCache {
    @Inject private DatabaseService db;
    
    @PostConstruct
    public void initialize() {
        cache.loadFrom(db);  // Setup после DI
    }
    
    public User find(Long id) { return cache.get(id); }  // Invocation
    
    @PreDestroy
    public void shutdown() {
        db.flush(cache);  // Cleanup
    }
}
```

Ошибки в @PostConstruct: bean не активируется, deploy fails.

Новое в EE 11: CDI 4.0 async lifecycle для @Asynchronous, интеграция с Concurrency 3.0.

## Дескрипторы развертывания

XML в META-INF/WEB-INF для declarative config. Парсятся на deploy; overrides аннотаций. Schema обновлены для Java 17+.

### Ключевые дескрипторы

|Файл|Назначение|Schema (EE 11)|Пример|
|---|---|---|---|
|**beans.xml**|CDI: alternatives, interceptors.|CDI 4.0|<beans><alternatives><class>DevService</class></alternatives></beans>|
|**web.xml**|Web: mappings, security.|Servlet 6.0|<servlet-mapping><url-pattern>/api/*</url-pattern></servlet-mapping>|
|**ejb-jar.xml**|EJB: beans, tx.|EJB 4.0|<session><ejb-name>Service</ejb-name><local>LocalIntf</local></session>|
|**persistence.xml**|JPA: units, providers.|JPA 3.1|<persistence-unit><provider>HibernatePersistenceProvider</provider></persistence-unit>|

**Пример web.xml**:

xml

```
<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee" version="6.0">
    <servlet>
        <servlet-name>UserServlet</servlet-name>
        <servlet-class>com.example.UserServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>UserServlet</servlet-name>
        <url-pattern>/users/*</url-pattern>
    </servlet-mapping>
</web-app>
```

Интеграция: <load-on-startup> triggers init() как @PostConstruct.

