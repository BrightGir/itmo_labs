## Обзор

Jakarta Mail — это спецификация (API) для работы с email в Jakarta EE (версия 2.1 в EE 11, релиз июнь 2025). Она позволяет отправлять, получать и обрабатывать письма: от простых текстовых сообщений до HTML с вложениями. В отличие от внешних библиотек (типа Apache Commons Email), Mail встроена в EE, работает с контейнером (WildFly, GlassFish) и интегрируется с CDI/EJB для транзакций.

**Почему Mail?** В enterprise-apps email — для уведомлений (регистрация, заказы), отчетов. API не "готовый почтовик" — это низкоуровневый инструмент: ты настраиваешь SMTP/IMAP вручную. Минимальная Java — 17. В EE 11: async-отправка через Virtual Threads, но базово синхронно.

**Где доступна?** Full и Web Profile (не Core — для микросервисов бери внешние). Реализация: Angus Mail (от Eclipse). Установка в standalone: Maven dep или JNDI-ресурс.

Ресурсы: Доки [jakarta.ee/specifications/mail/2.1](https://jakarta.ee/specifications/mail/2.1), туториал Mailtrap.

## Основы: Как устроен API

API — как конструктор писем: настраиваешь "сессию" (Session — глобальные настройки SMTP/IMAP), создаешь "сообщение" (Message — from/to/subject/content), отправляешь (Transport). Нет GUI — чистый код.

**Шаги работы**:

1. **Настройка**: Properties для сервера (host, port, auth).
2. **Сессия**: Session.getInstance() — "фабрика" сообщений.
3. **Сообщение**: MimeMessage — тело письма (текст/HTML, вложения).
4. **Отправка**: Transport.send() — по SMTP.
5. **Получение**: Store/Folder — чтение из ящика.

**Ключевые классы** (простая таблица):

|Класс|Что это|Зачем нужно|
|---|---|---|
|**Session**|Настройки почты (SMTP/IMAP).|Создать один раз на app, инжектировать в бины.|
|**MimeMessage**|Одно письмо (от кого, кому, тема, тело).|Основной объект: setFrom(), setText(), setContent().|
|**Transport**|"Почтальон" для отправки.|Transport.send(msg) — шлет по сети.|
|**Store/Folder**|Доступ к ящику (IMAP).|store.connect() — открыть inbox, читать сообщения.|
|**Multipart**|Контейнер для вложений/HTML.|Если письмо сложное: добавь части (текст + файл).|

**Ошибки новичков**: Забыть auth (для Gmail — app password), порт (587 для TLS). Тестируй на Mailtrap/SendGrid — не спамь реальные ящики.

## Отправка email: По шагам

Отправка — 80% использования Mail. Начни с простого текста, добавь HTML/файлы. Всё синхронно, но в EE можно async.

### 1. Простое текстовое письмо

**Что делаем**: Настраиваем SMTP (Gmail как пример), создаем сообщение, шлем.

**Шаг за шагом**:

- Импорты: import jakarta.mail.*; import jakarta.mail.internet.*;
- Properties: Укажи сервер (smtp.gmail.com), порт, TLS, auth.
- Session: С аутентификатором (логин/пароль).
- Message: Установи from/to/subject/text.
- Send: Transport.send().

**Код с объяснениями** (комментарии внутри):


```java
import jakarta.mail.*;  // Основные классы Mail
import jakarta.mail.internet.*;  // Для адресов и MIME
import java.util.Properties;

public class SimpleEmailSender {
    public static void main(String[] args) throws Exception {
        // Шаг 1: Настройки SMTP (для Gmail: включи 2FA и app password)
        Properties props = new Properties();
        props.put("mail.smtp.host", "smtp.gmail.com");  // Сервер отправки
        props.put("mail.smtp.port", "587");  // Порт с TLS
        props.put("mail.smtp.auth", "true");  // Включи авторизацию
        props.put("mail.smtp.starttls.enable", "true");  // Защита соединения

        // Шаг 2: Сессия с логином (анонимный класс для пароля)
        Session session = Session.getInstance(props, new Authenticator() {
            @Override
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("your.email@gmail.com", "your-app-password");
            }
        });

        // Шаг 3: Создай сообщение
        Message msg = new MimeMessage(session);
        msg.setFrom(new InternetAddress("your.email@gmail.com"));  // От кого
        msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse("friend@example.com"));  // Кому
        msg.setSubject("Привет из Jakarta Mail!");  // Тема
        msg.setText("Это простое тестовое письмо.");  // Тело (текст)

        // Шаг 4: Отправь
        Transport.send(msg);  // Синхронно: ждет ответа от сервера
        System.out.println("Письмо отправлено!");
    }
}
```

- **Тестирование**: Запусти, проверь inbox получателя. Ошибка? Проверь props (порт 465 для SSL).

### 2. HTML-письмо или с вложениями

**Что добавляем**: Multipart для смешанного контента (HTML + текст) или файлов. MimeMultipart — "коробка" с частями.

**Шаг за шагом**:

- Создай Multipart("alternative") для HTML/текст.
- Добавь BodyPart (части): одну для текста, одну для HTML.
- Для вложения: MimeBodyPart.attachFile().

**Код** (расширение простого):


```java
// ... (props и session как выше)

Message msg = new MimeMessage(session);
// ... (from, to, subject как выше)

// Для HTML: просто
msg.setContent("<h1>Привет!</h1><p>Это <b>жирный</b> текст.</p>", "text/html");

// Или Multipart (HTML + plain текст как fallback)
Multipart multipart = new MimeMultipart("alternative");  // "alternative" — выберет лучший
BodyPart textPart = new MimeBodyPart();  // Часть 1: простой текст
textPart.setText("Простой текст (если HTML не поддерживается)");
BodyPart htmlPart = new MimeBodyPart();  // Часть 2: HTML
htmlPart.setContent("<h1>Привет!</h1><p>Это HTML.</p>", "text/html");
multipart.addBodyPart(textPart);
multipart.addBodyPart(htmlPart);
msg.setContent(multipart);

// Вложение (PDF или картинка)
MimeBodyPart attachPart = new MimeBodyPart();
attachPart.attachFile(new java.io.File("/path/to/file.pdf"));  // Локальный файл
// Или из байтов: attachPart.setDataHandler(new DataHandler(new ByteArrayDataSource(bytes, "application/pdf")));
multipart.addBodyPart(attachPart);  // Добавь в multipart

Transport.send(msg);
```

- **Почему Multipart?** Получатели без HTML увидят текст. Вложения — отдельная часть, не портит тело.

### 3. Массовые рассылки (bulk)

**Проблема**: Gmail лимит 500/день. Решение: Батчи + паузы.

- Разбей список email на группы по 50.
- Используй ExecutorService для async (не блокируй).

**Код-сниппет**:


```java
import java.util.concurrent.*;

// В методе
List<String> emails = List.of("1@ex.com", "2@ex.com");  // Твой список
ExecutorService executor = Executors.newFixedThreadPool(5);  // 5 потоков
for (List<String> batch : partition(emails, 50)) {  // Функция разбиения (напиши сам)
    for (String to : batch) {
        executor.submit(() -> {
            try {
                // Создай msg для to, send
                Message msg = new MimeMessage(session);
                msg.setRecipients(..., InternetAddress.parse(to));
                // ... остальное
                Transport.send(msg);
            } catch (Exception e) { /* Лог */ }
        });
    }
    Thread.sleep(10000);  // Пауза 10 сек между батчами
}
executor.shutdown();
```

## Получение email: По шагам

Меньше используется, но для inbox-мониторинга (e.g., подтверждения).

**Шаг за шагом**:

- Properties для IMAP (imap.gmail.com:993).
- Store.connect() — подключись.
- Folder.open() — открой папку (INBOX).
- getMessages() — массив писем.
- Парсинг: getSubject(), getContent() (или Multipart).

**Код**:

```java
// ... импорты

Properties props = new Properties();
props.put("mail.store.protocol", "imaps");  // IMAP с SSL
props.put("mail.imap.host", "imap.gmail.com");
props.put("mail.imap.port", "993");

Session session = Session.getInstance(props);
Store store = session.getStore("imaps");
store.connect("your.email@gmail.com", "password");  // Логин

Folder inbox = store.getFolder("INBOX");
inbox.open(Folder.READ_ONLY);  // Только чтение

Message[] messages = inbox.getMessages(1, 10);  // Первые 10
for (Message msg : messages) {
    System.out.println("От: " + msg.getFrom()[0]);
    System.out.println("Тема: " + msg.getSubject());
    
    Object content = msg.getContent();
    if (content instanceof String) {
        System.out.println("Текст: " + content);
    } else if (content instanceof Multipart) {
        Multipart mp = (Multipart) content;
        for (int i = 0; i < mp.getCount(); i++) {
            BodyPart part = mp.getBodyPart(i);
            if (part.getContentType().contains("text/plain")) {
                System.out.println("Plain: " + part.getContent());
            }
        }
    }
}

inbox.close(false);  // Не удаляй
store.close();
```

- **Совет**: Для polling — таймер в EJB (@Schedule), но лучше webhook'и.

## Интеграция с Jakarta EE

В EE не пиши main() — инжектируй Session через JNDI (@Resource) в EJB/CDI-bean. Контейнер управляет ресурсами (pooling).

**Пример в EJB**:

java

```
@Stateless  // EJB для транзакций
public class NotificationService {
    @Resource(lookup = "java:jboss/mail/Default")  // JNDI в WildFly (настрой в standalone.xml)
    private Session mailSession;  // Инжектировано
    
    public void sendWelcome(String to, String name) {
        try {
            Message msg = new MimeMessage(mailSession);  // Используй injected
            msg.setFrom(...);
            msg.setRecipients(..., InternetAddress.parse(to));
            msg.setSubject("Добро пожаловать, " + name);
            msg.setText("Привет! Твой аккаунт готов.");
            Transport.send(msg);  // Авто-использует props из JNDI
        } catch (MessagingException e) {
            // Лог или throw
        }
    }
}
```

- **Настройка JNDI**: В server config: <resource-ref name="mail/Default"> с props (host/auth).
- **В CDI**: Producer-метод: @Produces Session createSession() { ... }.