## Что такое веб-сервисы и зачем они

Веб-сервисы — это когда твоё приложение "разговаривает" с другими приложениями по сети, как API, но для серверов. Например, в онлайн-магазине ты шлёшь заказ в платёжный сервис (типа Stripe) — он проверяет карту и отвечает "OK" или "ошибка". Без этого всё вручную, с файлами или email.

В Jakarta EE (EE 11, 2025) два инструмента:

- **JAX-RS** — для REST: простой, как запросы в браузере (GET /products — список товаров в JSON).
- **JAX-WS** — для SOAP: строгий, как официальный договор (XML с подписью, для банков).

Оба позволяют создать "эндпоинт" (URL для вызова) и обрабатывать запросы. Разница: REST лёгкий и гибкий, SOAP — тяжёлый, но с гарантиями (контракт WSDL). В EE они интегрируются с CDI (инжект зависимостей) и контейнером (WildFly сам маппит URL).

## JAX-RS: Как создать REST API (просто и быстро)

JAX-RS — для современных API. REST — это не протокол, а стиль: используй HTTP-методы (GET для чтения, POST для создания), возвращай JSON, пути как /api/users/1. Клиент (мобилка или фронт) зовёт URL, ты отвечаешь данными.

**Шаги создания**:

1. Аннотируй класс @Path("/api/users") — базовый URL.
2. Добавь методы: @GET для списка, @POST для добавления.
3. Верни POJO — контейнер превратит в JSON (с Jackson или JSON-B).
4. Разверни в WAR — готово, тести в Postman.

**Пример из жизни**: API для пользователей в магазине. Клиент (app) GET /api/users/1 — получает профиль, POST /api/users — создаёт нового.

**Код (шаг за шагом)**:


```java
import jakarta.ws.rs.*;  // Импорты JAX-RS
import jakarta.inject.Inject;  // Для CDI
import jakarta.ws.rs.core.*;  // Response

@Path("/api/users")  // Шаг 1: Базовый путь — все запросы /api/users/*
public class UserApi {  // Твой класс
  
  @Inject  // Шаг 2: Инжект сервиса (твоя логика)
  private UserService service;  // UserService — твой класс с findAll(), save()
  
  @GET  // Шаг 3: GET /api/users — список всех
  public Response getAllUsers() {
    List<User> users = service.findAll();  // Получи из БД
    return Response.ok(users).build();  // Верни JSON: [{"id":1,"name":"Alice"}]
  }
  
  @GET
  @Path("/{id}")  // Шаг 4: GET /api/users/1 — один юзер (/{id} — параметр)
  public Response getUser(@PathParam("id") Long id) {  // @PathParam — извлечёт id из URL
    User user = service.findById(id);
    if (user == null) {
      return Response.status(404).build();  // Не нашёл — 404
    }
    return Response.ok(user).build();  // JSON: {"id":1,"name":"Alice"}
  }
  
  @POST  // Шаг 5: POST /api/users — создать (тело запроса JSON)
  @Consumes(MediaType.APPLICATION_JSON)  // Принимай JSON
  @Produces(MediaType.APPLICATION_JSON)  // Отвечай JSON
  public Response createUser(User newUser) {  // newUser — POJO, парсится из тела
    service.save(newUser);  // Сохрани
    return Response.status(201).entity(newUser).build();  // 201 Created + JSON
  }
}
```

- **User — POJO**: public class User { private Long id; private String name; // геттеры/сеттеры } — JSON-B сделает JSON.
- **Тести**: Запусти сервер, GET [http://localhost:8080/api/users](http://localhost:8080/api/users) — увидишь список. POST с JSON в Postman — создастся.

**Плюсы**: Легко, быстро, масштабируемо. Минусы: Нет встроенного контракта (документируй Swagger).

## JAX-WS: Как создать SOAP-сервис (для строгих случаев)

JAX-WS — для SOAP: сообщения в XML, с WSDL (авто-документ — "что я умею"). Тяжёлый (XML большой), но с гарантиями: security, ошибки в Fault.

**Шаги создания**:

1. Аннотируй класс @WebService — генерит WSDL.
2. Добавь методы @WebMethod.
3. Разверни — WSDL по /service?wsdl.
4. Клиент: Генерит stub из WSDL (wsimport), зовёт как локальный метод.

**Пример из жизни**: Сервис оплаты в банке. Клиент (магазин) зовёт processPayment — получает XML "OK".

**Код (шаг за шагом)**:


```java
import jakarta.jws.*;  // Импорты JAX-WS
import jakarta.inject.Inject;

@WebService  // Шаг 1: Это сервис — генерит WSDL
public class PaymentService {  // Разверни как endpoint
  
  @Inject private PaymentDao dao;  // Твоя логика (CDI)
  
  @WebMethod  // Шаг 2: Метод в контракте WSDL
  public String processPayment(@WebParam(name = "amount") double amount, 
                               @WebParam(name = "cardNumber") String card) {
    // Логика: проверь
    if (amount <= 0 || card.length() < 16) {
      throw new PaymentException("Invalid data");  // Fault — XML-ошибка
    }
    dao.charge(card, amount);  // Спиши с карты
    return "Payment successful for " + amount;  // XML-ответ
  }
  
  // Другой метод
  @WebMethod
  public double getBalance(@WebParam(name = "card") String card) {
    return dao.getBalance(card);  // Верни баланс
  }
}
```

- **WSDL**: Авто по [http://localhost:8080/payment?wsdl](http://localhost:8080/payment?wsdl) — XML с описанием методов.
- **Клиент (генерится)**: wsimport -keep [http://server/payment?wsdl](http://server/payment?wsdl) — создаст PaymentService.java. Вызов: PaymentService port = new PaymentServiceService().getPaymentServicePort(); String result = port.processPayment(100.0, "4111...");
- **Тести**: SOAP UI — загрузи WSDL, вызови метод, увидишь XML.

**Плюсы**: Контракт (WSDL — "что ожидать"), security built-in. Минусы: XML тяжёлый, сложнее код.

## JAX-RS vs JAX-WS: Когда что выбрать

- **JAX-RS**: Для новых API (мобилки, фронты) — быстро, JSON. 90% случаев.
- **JAX-WS**: Для старых систем (банки, где нужен SOAP) — контракт, надёжность.
- **Микс**: В одном app — REST для публичного, SOAP для internal.

**В EE 11**: JAX-RS 4.0 — async с Virtual Threads, JAX-WS 4.0 — проще с CDI.